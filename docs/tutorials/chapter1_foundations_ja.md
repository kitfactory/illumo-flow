# 第1章 · 基本コンセプト

本章ではコードを書く前提として Illumo Flow の発想と設計原理を整理します。まずは実行基盤を成す **Flow** と **Node** の役割・インターフェースを押さえ、そのうえでランタイムが扱う二大要素である **ペイロード** と **コンテキスト** を共通認識にします。

**Flow**
- グラフ構造で結ばれたノード群をオーケストレーションするランナーです。`Flow.from_dsl(nodes, entry, edges)` や `Flow.from_config(...)` で構築し、`flow.run(context=None, user_input=None)` を呼び出すとエントリーノードから順に実行されます。
- 実行中はノードの出力やルーティング結果を `context['payloads']` や `context['routing']` に記録し、ジョイン待ちの管理やブランチ配信などを自動で行います。

**Node**
- `Node` 基底クラスを継承した処理単位で、最低限 `run(self, payload)` を実装します。戻り値が次ノードへのペイロードになり、`FunctionNode` / `RoutingNode` / `LoopNode` などの具象実装を組み合わせます。
- `inputs` で `$ctx.xxx` や `$payload.xxx` を解決して入力を構成し、`outputs` で `$ctx.data.cleaned` のように宣言的にコンテキストへ書き込みます。暗黙でコンテキストを触らない設計が基本で、必要な場合のみ `allow_context_access=True` を明示します。

Flow と Node の責務を把握したうえで、次にペイロードとコンテキストの使い分けを整理します。

## 1.1 ペイロードとコンテキストの違い
| 概念 | 役割 | ライフサイクル | 実装ガイドライン |
| --- | --- | --- | --- |
| ペイロード | 各ノードの `run(payload)` へ渡される値。次ノードに必要な最小情報だけを持たせる | ノードが生成・返却しつつ必要に応じて加工。後続が処理を終えると破棄 | ノード内では基本的に不変として扱う。辞書などテストしやすい形にする |
| コンテキスト | ランタイムが管理する共有監査辞書（`context['payloads']`, `context['joins']` など） | 実行開始時に初期化され、ペイロード履歴・ジョイン結果・ルーティング情報・宣言済み出力が自動で蓄積 | 読み取り中心に使う。書き込みは `outputs` または `allow_context_access=True` を有効化した場合の明示的操作に限定 |

**設計プリンシプル**
- ペイロードはノード間の契約。設定値などの外部依存を除き、ペイロードだけで処理できるように設計する。
- コンテキストはフローの進捗観測用。ペイロード履歴やジョイン結果などが自動で記録されるため、手動更新は例外的な用途に絞る。
- 共有状態を更新する必要がある場合（例: メトリクス追加）は `allow_context_access=True` を設定し、利用するキーやスキーマをドキュメント化する。

これらを踏まえて、以降の節でフローを保守可能に保つための指針を掘り下げます。

## 1.2 ペイロード優先の意義
- **単一責務**: ノードは受け取ったペイロードを変換して次へ渡すだけです。共有コンテキストは台帳の役割に留め、暗黙の書き換えを避けます。
- **テスト容易性**: 純粋関数に近い形で実装できるためユニットテストが容易です。コンテキストが必要な場合のみ `allow_context_access=True` を明示します。
- **分離性**: ペイロードだけで成り立つノードは別環境でも再実行しやすく、記録したペイロードを用いたリプレイも簡単です。

## 1.3 フェイルファスト実行モデル
- 例外が発生すると即時停止し、`context["errors"]` や `context["failed_node_id"]` などへ診断情報が記録されます。
- 下流が不完全なデータで動かないため、フロー全体が決定的に振る舞います。
- リトライなどの回復処理はノード内で扱い、フローループ側で例外を握り潰さないようにします。

## 1.4 宣言的なグラフ配線
- ノードは処理内容を、エッジは実行順序やジョイン・ループを表現します。
- DSL の配線を差し替えるだけで同じノードを別フローに再利用できます。
- YAML/JSON/辞書の設定は第一級の手段であり、Python DSL と 1:1 で対応します。

## 1.5 コンテキストのメンタルモデル
共有コンテキストはランタイムが管理する辞書で、以下の情報を保持します。
- `context["payloads"][node_id]`: 各ノードの最新出力
- `context["joins"][node_id]`: 親ノードが複数ある場合の入力辞書
- `context["routing"][node_id]`: ルーティングノードが返した分岐や信頼度、理由
- `context["steps"]`: 実行タイムライン

コンテキストは監査ログとして捉え、ノード間の主要なやり取りはペイロードと宣言的な `outputs` に委ねるのが原則です。

## 設計・実装ポイントまとめ
- **ペイロード設計**: ノード間でやり取りするデータ構造を書き出し、ペイロードだけで処理が完結するかを確認する。
- **コンテキスト出力**: 結果を書き込むパス（例: `$ctx.data.cleaned`）を事前に決め、宣言的な `outputs` で記録する。
- **コンテキストアクセス**: ペイロードだけで成立しない場合に限って `allow_context_access=True` を許可し、利用キーを明示する。
- **フェイルファスト運用**: 外部 API 呼び出しはヘルパーでリトライを実装し、想定外の例外がフロー全体に伝播するように保つ。
- **エラーハンドリング**: 診断に役立つメッセージと例外型を整備し、テストで期待する失敗を検証可能にする。
- **グラフ配線管理**: ビジネス意図が伝わるノード ID を付け、`"(geo & risk) >> merge"` のような DSL 文字列で配線を表現し、設定ファイルをバージョン管理する。
