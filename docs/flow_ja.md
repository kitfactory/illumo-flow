# Flow 設計ガイド

## スコープ
- `Flow` インスタンスがグラフ実行・ルーティング・コンテキスト管理をどのように調停するかを定義する。
- `Node` 実装と共有 `context` 辞書に課される契約を明文化する。
- 直列・動的分岐・ファンイン/ファンアウト・リトライなど、ランタイムが扱うべきシナリオを列挙し、それぞれのモデリング方法を示す。

## 用語
- **Flow**: グラフ、実行キュー、ランタイムポリシーを保持するスケジューラ兼オーケストレータ。
- **Node**: 入力を変換し、共有コンテキストへ情報を追加する実行単位。
- **Edge**: DSL/設定で宣言された後続ノード候補を示す接続。
- **Routing**: 実行時のルートが確定していない場合に、Flow が参照するためノードがコンテキストへ書き込むルーティング指示。
- **Context**: 各ノードがペイロード、メタデータ、診断結果を共有する可変辞書。
- **Join Target**: 複数の上流結果を待つノード（複数の親エッジを持つノードが自動的に該当）。

## 中核の責務
### Flow
- ビルド時にグラフを検証し、孤立ノード・欠落依存・サイクルを拒否する。
- 隣接リストを整備する: `outgoing[node_id] -> set[edge]`, `incoming[node_id] -> set[parent_id]`。
- `ready` / `inflight` / `waiting_for_join` の3バケットでスケジューリングし、前提条件が揃ったノードを実行する。
- ノード結果を受け取り、コンテキストに書き込まれたルーティング指示を正規化し、後続ノードをキューへ投入した後に指示をクリアする。
- ジョイン用ペイロードを集約し、必要な上流が揃った時点で下流ノードを解放する。
- 並列数制限を適用しつつ Fail-Fast を維持し、リトライやグローバルタイムアウトは組み込まない。
- 失敗時は早期終了し、事後分析用の診断情報を記録する。

### Node
- サブクラスは `handle(payload, ctx_view) -> payload` を実装する。`payload` は `inputs` で解決された値であり、`ctx_view` は読み取りとルーティング指示 (`ctx_view.route(...)`)、限定的な書き込み (`ctx_view.write(...)`) を提供する。
- `run_async` は既定で `handle` を同期呼び出しし、必要に応じて拡張できる。
- ツールやバリデーションのために `describe()` でメタデータを公開し、参照/書き込みするコンテキストキーを列挙する。
- 単一責務を守り、1ノード=1処理または1つの判断境界とする。
- 初期化時に静的後続 (`self.next_route`) を設定するか、実行時に `ctx_view.route(...)` を呼び出して分岐を指示する。
- `inputs` / `outputs`（DSL の `context.inputs` / `context.outputs`）を使って、コンテキスト上の特定のパスから読み書きする。ノードは戻り値として payload を返すだけで、Flow が書き込みを代行する。
- Flow は必要なネームスペースを事前に用意し、ノードは式 (`$ctx.*` 等) で参照する。
- グラフ上のノードIDは Flow が組み立て時に割り当て（DSL/設定のキーを利用）、ノード実装はID非依存とし、同一インスタンスを複数フローで使い回せるようにする。
- すべてのノードは `name` を必ず指定し、Flow は空文字を拒否して診断情報に利用する（グラフ上のノードIDとは別管理）。
- 実装上、内部メトリクス用途のプライベート UUID を持つことは許容されるが、ルーティングやコンテキストキーとして公開しない。
- エッジで定義された親が複数ある場合、そのノードは自動的に全ての完了を待ってから実行される。
- ジョイン参加時は、下流で衝突なくマージできる構造化ペイロードを返す。
- Flow が用意した予約キー以外のネームスペースは `ctx_view.write()` などを通じて限定的に更新する。

### Context
- 以下の安定したネームスペースを提供する:
  - `context["steps"]`: `{timestamp, node_id, status, info}` 形式の実行ログ。
  - `context["routing"]`: ノードIDごとのルーティング決定。
  - `context["joins"]`: `join_id -> parent_id -> payload` を格納する多重マップ。
  - `context["errors"]`: ノード例外発生時のエラーレコード。
- 上記以外は利用者が任意のキーを追加できるが、予約キーは保護されるべき。
- Flow は実行前に `context["joins"]` や `context["routing"]` などの予約ネームスペースを初期化し、ノードが直接辞書を操作するのではなく `ctx_view` 経由でアクセスできるようにする。
- ルーティング決定の保存先は `context["routing"][node_id] = Routing` とし、標準的な辞書代入で記録する。
- `describe()` で宣言された `context_inputs` / `context_outputs` などを参照し、Flow が追加キーを事前確保・検証できる。
- `context["payloads"]`: 各ノードが最後に生成したペイロード。エントリノードは Flow が初期化し、ノード実装は自分のスロットを更新する。
- `context.output` に指定したパスへノードの出力を格納したり、`context.input` で指定したパスから入力を取得したりできる。
- 共有状態の更新は `ctx_view.write(...)` を通じて行い、Raw な辞書操作はサポート対象外とする。n8n / Dify と同様、コンテキストアクセスは Flow が提供する安全な API に限定する。
- `$` で始まる文字列は式として評価されます（例: `$ctx.data.raw`, `$env.API_KEY`）。
- 文字列内の `{{ ... }}` も式を受け付け、テンプレートとして展開されます。
- ノードに渡される `payload` は `inputs` から解決された値であり、共有 `context` とは分離しています。ノードは戻り値として `payload` を返し、Flow が `context["payloads"]` と `outputs` へ書き込みます。
- `ctx.*` / `payload.*` / `joins.*` といった `$` 省略形は自動的に `$ctx.*` 等へ正規化されます。`$.foo` のような短縮記法も `$ctx.foo` として扱われます。それ以外の文字列はリテラルのままです。

## ルーティング設計
### 静的ルーティング
- `A >> B` や `A >> (B | C)` のような DSL エッジから直接導出される。
- Flow は後続集合を事前計算し、実行時に分岐不要なノードは自動的にその集合を利用する。
- エントリノードから到達可能であることを検証し、存在しない後続は構築段階で拒否する。

### 動的ルーティング
- 実行時に分岐が必要なノードは `context["routing"][node_id]` に `Routing` エントリを保存する。
- `Routing` の構造例:
  ```python
  {
      "next": "B",             # 後続ノードID、ノードIDのリスト、もしくは None（停止）
      "confidence": 85,         # 0-100 の確信度
      "reason": "score が閾値を超過"
  }
  ```
- Flow は `next` に指定されたノードが静的に許可された後続集合に含まれるか検証し、違反時はルーティングエラーを送出する。
- 指示は追跡やリプレイのためにコンテキストへ保持され、消費後は Flow がクリアする。

## 設定ファイルからのロード
- `Flow.from_config(source)` は YAML/JSON ファイル、または辞書オブジェクトからフローを構築します。
- ノード定義では `type`、`callable`、`context.input` / `context.output`、`next_route`、`default_route`、`describe` などを指定できます。
- 設定例:

```yaml
flow:
  entry: extract
  nodes:
    extract:
      type: illumo_flow.core.FunctionNode
      name: extract
      context:
        inputs:
          callable: examples.ops.extract
        output: $ctx.data.raw
    transform:
      type: illumo_flow.core.FunctionNode
      name: transform
      context:
        inputs:
          callable: examples.ops.transform
          payload: $ctx.data.raw
        output: $ctx.data.normalized
    load:
      type: illumo_flow.core.FunctionNode
      name: load
      context:
        inputs:
          callable: examples.ops.load
          payload: $ctx.data.normalized
        output: $ctx.data.persisted
  edges:
    - extract >> transform
    - transform >> load
```

- 利用例:

```python
from illumo_flow import Flow

flow = Flow.from_config("flow.yaml")
context = {}
flow.run(context)

`Flow.run` は更新後の `context` を返し、各ノードの結果は `context["payloads"]` に保持されます。
```

`FunctionNode` は `context.inputs.callable` に実装パスを指定します。リテラル文字列はフロー構築時にインポートされ、`$.registry.transform` のような式は実行時にコンテキストから評価されます。

### ファンアウト / ブロードキャスト
- `A | B` の両エッジを発火させるケースでは、Flow が出力ペイロードをターゲットごとに複製し、親ノードIDを付与する。
- ノードが `Routing["next"]` に複数ID（例: `["B", "C"]`）を設定すれば、DSL が選択集合であっても全分岐をブロードキャストできる。

### ファンイン / ジョイン
- 複数の親エッジを持つノードは自動的にジョイン対象となる。
- Flow は `pending[(join_id)] -> remaining_count` のカウンタで残タスクを追跡する。
- 各上流完了時に `context["joins"][join_id][parent_id]` へペイロードを保存する。
- カウンタが0になったら、集約入力を添えてジョインノードを ready キューへ移す。

### デフォルト・終端ルート
- ルーティング指示が空でも遷移させたい場合、ノードは `default_route` を持てる。
- `Routing["next"] = None`（必要に応じて `confidence` / `reason` を添える）とすると、Flow に正常終了を指示できる。

## 実行ライフサイクル
1. DSL/設定を内部グラフ表現へコンパイルする。
2. 実行状態を初期化し（コンテキスト予約キー、ready キューにエントリノードを投入）、ループを開始する。
3. ディスパッチループ:
   - 並列上限を守りつつキューからノードを取得。
   - `inputs` からペイロードを解決し、`Node.handle(payload, ctx_view)` を呼び出す。
   - 成功時: ステップを記録し、戻り値を `outputs` へ保存し、`ctx_view.route(...)` を読み取って後続を投入し、消費した指示をクリア。
   - 失敗時: 診断情報を収集し、失敗キーを設定し、ループを中断。
4. 終了処理: 最終ノードが出力したペイロードを `Flow.run` の戻り値として返し、コンテキストはインプレースに更新された状態で残す。

## 状態管理構造
- `GraphIndex`: 隣接リスト、逆エッジ、ジョイン要件を保持するデータクラス。
- `ExecutionState`: キュー、進行中カウンタ、キャンセル用トークンなど実行に必要なメタデータを内包。
- `ContextManager`: `record_join` / `record_routing` / `push_error` などを Flow 内部で扱い、追加APIをユーザーに公開しない。
- `RouteValidator`: ルーティング指示の正規化と不正遷移の早期検知を担当。

## 並列性と順序保証
- 依存衝突のないノードは並列実行でき、Flow はノードIDごとの未完了タスク数を追跡する。
- 衝突し得るコンテキスト書き込みは Flow が内部で同期化し、利用者は宣言的な記述に集中できる。
- 単一分岐内の順序は保持され、マージはスケジューラ順ではなくジョインの語彙に依存する。
- タイムアウト管理はノード実装側の責務であり、Flow は発生した例外をそのまま扱う。

## エラーハンドリング戦略
- デフォルトは Fail-Fast: 最初の例外で実行を中断するが、診断用に部分的なコンテキストを保持する。
- 例外送出前に `context["failed_node_id"]`, `context["failed_exception_type"]`, `context["failed_message"]` を必ず設定する。
- 回復可能なケースでは `Routing["next"] = None` を設定し、理由を添えて正常停止できる。
- リトライやタイムアウト管理はアプリケーション側（各ノード）で実装し、Flow は結果を受け取って記録する。

## 可観測性要件
- ノード開始・完了・失敗・ルーティング決定ごとに構造化ログを発行する。
- トレーシング統合を想定し、ノード単位でスパンを生成できるよう Flow からコールバックを提供する。
- 成功数・失敗数・ノードごとのレイテンシなどのメトリクスを Flow のフック経由で取得できるようにする。

## 将来拡張の検討ポイント
- **拡張フック**: `Node.describe()` から構造化メタデータを公開し、Flow 実行の前後フックを用意してロギング／トレーシング／メトリクスを注入しやすくする。
- **エラー／リトライ方針**: Fail-Fast を基本に保ちながら、任意でリトライやバックオフ、失敗通知を差し込めるプラグイン構造を検討する。
- **可観測性ツール**: 実行トレースやステップ時間を外部ダッシュボードへ送れるエクスポータを整備する。
- **設定バリデーション**: `context.inputs` / `context.outputs`、式、callable 指定の静的検証を強化し、実行前に誤りを検出する。
- **UI 連携準備**: `Flow.to_config()` のようなシリアライズ機構、ノードカタログの機械可読化、式・バリデーション規約の明文化によりワークフロー編集 UI への展開を容易にする。

### ロードマップ
**これまでの歩み**: バージョン 0.1.2 でペイロード主導のインターフェースへ刷新し、`$ctx` / `$.` 式や YAML 構成を統合しました。今後はこの基盤の上に、拡張フック・検証・可観測性・UI 連携を計画的に積み上げます。

**短期（0.1.x）**
- `Flow.run` がコンテキストを返す仕様を周知し、ノードが生コンテキストを直接書き換えず `ctx.write` などを利用するガイドを整備。
- `Node.describe()` からの構造化メタデータ拡充と、Flow 実行前後フックの追加設計。
- `context.inputs` / `context.outputs` / callable 指定の静的バリデーションを強化し、エラーを実行前に検出。
- コンテキストビュー API (`ctx.get` / `ctx.write` / `ctx.route`) を用いたベストプラクティスをサンプルとドキュメントに追加。

**中期（0.2.x）**
- Fail-Fast を維持しつつ、任意でリトライ・バックオフ・失敗通知を差し込めるポリシーをプラグイン化。
- OpenTelemetry や JSON エクスポータなど、トレース／メトリクスの標準アダプタを提供。
- ノードカタログの JSON スキーマを公開し、外部ツールから入出力メタデータを取得可能に。
- `Flow.to_config()` / `Flow.diff_config()` を整備し、UI とコードの往復編集を支援。

**長期（0.3.x 以降）**
- 必要に応じて分散実行・バックプレッシャ制御を検討しつつ、単一プロセス実装との互換性を保持。
- カタログとバリデーションスキーマを活用したリファレンス UI（または設計キット）を提供。
- イベントストリームや永続的な監査ログなど、ポリシー駆動の可観測性パイプラインを提供。
- コミュニティ貢献ノード／統合を管理する `FlowPlugin` レジストリを正式化し、エコシステム拡大を支援。
## 対応すべきシナリオチェックリスト
- 直列パイプライン (`A >> B >> C`)。
- 静的ファンアウト (`A >> (B | C)` が両方発火)。
- ランタイムの選択分岐（ルーターノードが後続を選択）。
- ファンインを伴う並列処理 (`(B & C) >> join`)。
- 早期終了 (`Routing["next"] = None`)。
- （ノード側で実装される）タイムアウトによるキャンセル。
- 外部イベント待機（ノードが非同期処理を返し Flow が待機制御）。

## テスト用フロー例
- **線形 ETL チェーン**: `extract >> transform >> load`。順序の決定性、コンテキストの蓄積、`transform` 例外時のフェイルファスト挙動を確認。
- **信頼度付きルーティング**: `classify` ノードが `Routing` に `next="approve"` や `"reject"` を書き込む。動的ルーティング、`confidence` の監査、低信頼度時の `default_route` フォールバックを検証。
- **並列エンリッチ + ジョイン**: `start >> (geo | risk)` から `merge` へ。並列スケジューリング、`context["joins"]` のバッファ処理、決定的な結合をテスト。
- **ノード内タイムアウト管理**: `call_api` が独自にタイムアウト/リトライを実装し、最終的に例外を投げる。Flow が Fail-Fast を維持しつつ、ノードが外部信頼性をカプセル化する例。
- **早期停止ウォッチドッグ**: しきい値超過で `guard` が `Routing["next"] = None` を設定。正常停止、実行ログの完備性、停止後の余剰タスクが無いことを検証。

## Node 実装チェックリスト
- [ ] 可読な `name` と `describe()` メタデータを宣言する。
- [ ] 先に用意されたネームスペースへ通常の辞書代入でジョイン/ルーティング情報を書く。
- [ ] 衝突を避けるユニークなキーでペイロードを返す。
- [ ] `context["payloads"][node_id]` へ生成したペイロードを格納し、下流ノードへの入力を整える。
- [ ] 例外は握りつぶさずに送出し、Flow がログと Fail-Fast を担う（自動リトライはしない）。
- [ ] 非同期処理ではノード内でタイムアウト/キャンセルを管理し、即座に例外を伝播させる。
- [ ] 必須コンテキストキーを `describe()` メタデータに記載し、バリデーションツールが検証可能にする。

## Flow 実装チェックリスト
- [ ] グラフ構築時に到達不能ノードや重複IDを検証する。
- [ ] 実行開始時に予約ネームスペースを初期化する。
- [ ] 並列上限を強制しつつ、タイムアウト管理はノード実装に委ねる。
- [ ] コンテキストから取得したルーティング指示を正規化・記録し、消費後にエントリをクリアする。
- [ ] ジョイン集約をアトミックかつ決定的に保つ。
- [ ] 例外送出前に十分な診断情報をコンテキストへ格納する。
- [ ] 計測・カスタムスケジューラ用の拡張フックを公開しつつ、内部表現を漏洩させない。
