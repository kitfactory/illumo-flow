# Flow 設計ガイド

## スコープ
- `Flow` インスタンスがグラフ実行・ルーティング・コンテキスト管理をどのように調停するかを定義する。
- `Node` 実装と共有 `context` 辞書に課される契約を明文化する。
- 直列・動的分岐・ファンイン/ファンアウト・リトライなど、ランタイムが扱うべきシナリオを列挙し、それぞれのモデリング方法を示す。

## 用語
- **Flow**: グラフ、実行キュー、ランタイムポリシーを保持するスケジューラ兼オーケストレータ。
- **Node**: 入力を変換し、共有コンテキストへ情報を追加する実行単位。
- **Edge**: DSL/設定で宣言された後続ノード候補を示す接続。
- **Routing**: 実行時のルートが確定していない場合に、Flow が参照するためノードがコンテキストへ書き込むルーティング指示。
- **Context**: 各ノードがペイロード、メタデータ、診断結果を共有する可変辞書。
- **Join Target**: `.requires(...)` を宣言し、複数の上流結果を待つノード。

## 中核の責務
### Flow
- ビルド時にグラフを検証し、孤立ノード・欠落依存・サイクルを拒否する。
- 隣接リストを整備する: `outgoing[node_id] -> set[edge]`, `incoming[node_id] -> set[parent_id]`。
- `ready` / `inflight` / `waiting_for_join` の3バケットでスケジューリングし、前提条件が揃ったノードを実行する。
- ノード結果を受け取り、コンテキストに書き込まれたルーティング指示を正規化し、後続ノードをキューへ投入した後に指示をクリアする。
- ジョイン用ペイロードを集約し、必要な上流が揃った時点で下流ノードを解放する。
- 並列数制限を適用しつつ Fail-Fast を維持し、リトライやグローバルタイムアウトは組み込まない。
- 失敗時は早期終了し、事後分析用の診断情報を記録する。

### Node
- 同期メソッド `run(user_input: str | None = None, context: dict) -> dict` を実装し、必要に応じて `run_async` で委譲する。
- ツールやバリデーションのために `describe()` でメタデータを公開し、参照/書き込みするコンテキストキーを列挙する。
- 単一責務を守り、1ノード=1処理または1つの判断境界とする。
- 初期化時に静的後続 (`self.next_route`) を設定するか、実行時に戻り値のコンテキストへ `Routing` エントリを添付する。
- Flow が必要なネームスペースを事前に用意するため、ノードは通常の辞書操作だけで読み書きできる。
- グラフ上のノードIDは Flow が組み立て時に割り当て（DSL/設定のキーを利用）、ノード実装はID非依存とし、同一インスタンスを複数フローで使い回せるようにする。
- 実装上、内部メトリクス用途のプライベート UUID を持つことは許容されるが、ルーティングやコンテキストキーとして公開しない。
- コード上では `FunctionNode(...).requires("A", "B")` のようなフルーエント API で依存親を宣言できる。
- ジョイン参加時は、下流で衝突なくマージできる構造化ペイロードを返す。
- Flow が用意した予約キー以外のネームスペースは破壊的に変更しないよう注意する。

### Context
- 以下の安定したネームスペースを提供する:
  - `context["steps"]`: `{timestamp, node_id, status, info}` 形式の実行ログ。
  - `context["routing"]`: ノードIDごとのルーティング決定。
  - `context["joins"]`: `join_id -> parent_id -> payload` を格納する多重マップ。
  - `context["errors"]`: ノード例外発生時のエラーレコード。
- 上記以外は利用者が任意のキーを追加できるが、予約キーは保護されるべき。
- Flow は実行前に `context["joins"]` や `context["routing"]` などの予約ネームスペースを初期化し、ノードは追加のヘルパに頼らず辞書操作で更新できる。
- ルーティング決定の保存先は `context["routing"][node_id] = Routing` とし、標準的な辞書代入で記録する。
- `describe()` で宣言された `context_inputs` / `context_outputs` などを参照し、Flow が追加キーを事前確保・検証できる。
- `context["payloads"]`: 各ノードが最後に生成したペイロード。エントリノードは Flow が初期化し、ノード実装は自分のスロットを更新する。

## ルーティング設計
### 静的ルーティング
- `A >> B` や `A >> (B | C)` のような DSL エッジから直接導出される。
- Flow は後続集合を事前計算し、実行時に分岐不要なノードは自動的にその集合を利用する。
- エントリノードから到達可能であることを検証し、存在しない後続は構築段階で拒否する。

### 動的ルーティング
- 実行時に分岐が必要なノードは `context["routing"][node_id]` に `Routing` エントリを保存する。
- `Routing` の構造例:
  ```python
  {
      "next": "B",             # 後続ノードID、ノードIDのリスト、もしくは None（停止）
      "confidence": 85,         # 0-100 の確信度
      "reason": "score が閾値を超過"
  }
  ```
- Flow は `next` に指定されたノードが静的に許可された後続集合に含まれるか検証し、違反時はルーティングエラーを送出する。
- 指示は追跡やリプレイのためにコンテキストへ保持され、消費後は Flow がクリアする。

### ファンアウト / ブロードキャスト
- `A | B` の両エッジを発火させるケースでは、Flow が出力ペイロードをターゲットごとに複製し、親ノードIDを付与する。
- ノードが `Routing["next"]` に複数ID（例: `["B", "C"]`）を設定すれば、DSL が選択集合であっても全分岐をブロードキャストできる。

### ファンイン / ジョイン
- `.requires("A", "B")` を宣言したノードをジョイン対象として登録する。
- Flow は `pending[(join_id)] -> remaining_count` のカウンタで残タスクを追跡する。
- 各上流完了時に `context["joins"][join_id][parent_id]` へペイロードを保存する。
- カウンタが0になったら、集約入力を添えてジョインノードを ready キューへ移す。

### デフォルト・終端ルート
- ルーティング指示が空でも遷移させたい場合、ノードは `default_route` を持てる。
- `Routing["next"] = None`（必要に応じて `confidence` / `reason` を添える）とすると、Flow に正常終了を指示できる。

## 実行ライフサイクル
1. DSL/設定を内部グラフ表現へコンパイルする。
2. 実行状態を初期化し（コンテキスト予約キー、ready キューにエントリノードを投入）、ループを開始する。
3. ディスパッチループ:
   - 並列上限を守りつつキューからノードを取得。
   - 現在のコンテキストスナップショットでノードを実行（同期/非同期）。
   - 成功時: ステップを記録し、コンテキスト差分をマージし、`Routing` エントリを読み取って後続を投入し、消費した指示をクリア。
   - 失敗時: 診断情報を収集し、失敗キーを設定し、ループを中断。
4. 終了処理: 最終ノードが出力したペイロードを `Flow.run` の戻り値として返し、コンテキストはインプレースに更新された状態で残す。

## 状態管理構造
- `GraphIndex`: 隣接リスト、逆エッジ、ジョイン要件を保持するデータクラス。
- `ExecutionState`: キュー、進行中カウンタ、キャンセル用トークンなど実行に必要なメタデータを内包。
- `ContextManager`: `record_join` / `record_routing` / `push_error` などを Flow 内部で扱い、追加APIをユーザーに公開しない。
- `RouteValidator`: ルーティング指示の正規化と不正遷移の早期検知を担当。

## 並列性と順序保証
- 依存衝突のないノードは並列実行でき、Flow はノードIDごとの未完了タスク数を追跡する。
- 衝突し得るコンテキスト書き込みは Flow が内部で同期化し、利用者は宣言的な記述に集中できる。
- 単一分岐内の順序は保持され、マージはスケジューラ順ではなくジョインの語彙に依存する。
- タイムアウト管理はノード実装側の責務であり、Flow は発生した例外をそのまま扱う。

## エラーハンドリング戦略
- デフォルトは Fail-Fast: 最初の例外で実行を中断するが、診断用に部分的なコンテキストを保持する。
- 例外送出前に `context["failed_node_id"]`, `context["failed_exception_type"]`, `context["failed_message"]` を必ず設定する。
- 回復可能なケースでは `Routing["next"] = None` を設定し、理由を添えて正常停止できる。
- リトライやタイムアウト管理はアプリケーション側（各ノード）で実装し、Flow は結果を受け取って記録する。

## 可観測性要件
- ノード開始・完了・失敗・ルーティング決定ごとに構造化ログを発行する。
- トレーシング統合を想定し、ノード単位でスパンを生成できるよう Flow からコールバックを提供する。
- 成功数・失敗数・ノードごとのレイテンシなどのメトリクスを Flow のフック経由で取得できるようにする。

## 対応すべきシナリオチェックリスト
- 直列パイプライン (`A >> B >> C`)。
- 静的ファンアウト (`A >> (B | C)` が両方発火)。
- ランタイムの選択分岐（ルーターノードが後続を選択）。
- ファンインを伴う並列処理 (`(B & C) >> join`)。
- 早期終了 (`Routing["next"] = None`)。
- （ノード側で実装される）タイムアウトによるキャンセル。
- 外部イベント待機（ノードが非同期処理を返し Flow が待機制御）。

## テスト用フロー例
- **線形 ETL チェーン**: `extract >> transform >> load`。順序の決定性、コンテキストの蓄積、`transform` 例外時のフェイルファスト挙動を確認。
- **信頼度付きルーティング**: `classify` ノードが `Routing` に `next="approve"` や `"reject"` を書き込む。動的ルーティング、`confidence` の監査、低信頼度時の `default_route` フォールバックを検証。
- **並列エンリッチ + ジョイン**: `start >> (geo | risk)` から `merge.requires("geo", "risk")` へ。並列スケジューリング、`context["joins"]` のバッファ処理、決定的な結合をテスト。
- **ノード内タイムアウト管理**: `call_api` が独自にタイムアウト/リトライを実装し、最終的に例外を投げる。Flow が Fail-Fast を維持しつつ、ノードが外部信頼性をカプセル化する例。
- **早期停止ウォッチドッグ**: しきい値超過で `guard` が `Routing["next"] = None` を設定。正常停止、実行ログの完備性、停止後の余剰タスクが無いことを検証。

## Node 実装チェックリスト
- [ ] 可読な `name` と `describe()` メタデータを宣言する。
- [ ] 先に用意されたネームスペースへ通常の辞書代入でジョイン/ルーティング情報を書く。
- [ ] 衝突を避けるユニークなキーでペイロードを返す。
- [ ] `context["payloads"][node_id]` へ生成したペイロードを格納し、下流ノードへの入力を整える。
- [ ] 例外は握りつぶさずに送出し、Flow がログと Fail-Fast を担う（自動リトライはしない）。
- [ ] 非同期処理ではノード内でタイムアウト/キャンセルを管理し、即座に例外を伝播させる。
- [ ] 必須コンテキストキーを `describe()` メタデータに記載し、バリデーションツールが検証可能にする。

## Flow 実装チェックリスト
- [ ] グラフ構築時に到達不能ノードや重複IDを検証する。
- [ ] 実行開始時に予約ネームスペースを初期化する。
- [ ] 並列上限を強制しつつ、タイムアウト管理はノード実装に委ねる。
- [ ] コンテキストから取得したルーティング指示を正規化・記録し、消費後にエントリをクリアする。
- [ ] ジョイン集約をアトミックかつ決定的に保つ。
- [ ] 例外送出前に十分な診断情報をコンテキストへ格納する。
- [ ] 計測・カスタムスケジューラ用の拡張フックを公開しつつ、内部表現を漏洩させない。
